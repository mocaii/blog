# 贪心算法概览：以局部之优，谋全局之胜

在算法科学的广阔领域，贪心算法作为一颗璀璨明星，凭借其直接了当的决策逻辑与针对特定问题的高效求解能力，赢得了显著地位。本文旨在深度剖析贪心算法的核心概念、特色属性、实施流程，并借助实际编程实例，揭示其在现实挑战中的应用价值，尤其是在诸如霍夫曼编码、Prim 与 Kruskal 的最小生成树算法等领域的应用。

## 一、贪心算法核心解读

### 1.1 基本定义

贪心算法（Greedy Algorithm），是一种在每个步骤中都**选择局部最优解**，以期望达到全局最优解的算法设计思想。这种算法并不总是寻找问题的精确解答，但它在许多情况下能迅速得到满意解。

### 1.2 特点总结

- 局部最优：每一步都做出当前看起来最佳的选择。
- 全局目标：目标是通过一系列局部最优决策达到全局最优。
- 适用范围：适用于具有`最优子结构`和`贪心选择性质`的问题。
- 效率：相比其他算法，贪心算法往往能更快得到解，但不一定总是全局最优。

### 1.3 贪心选择性质

贪心选择性质是贪心算法设计中的一个核心概念，它描述了在解决特定优化问题时的一种策略。贪心选择性质是指在每一步决策中，都做出局部上最佳的选择，期望通过这些局部最优解的组合来达到全局最优解。关键点包括：

- `局部最优`：在算法的每一步，算法都基于当前状态做出最佳选择，这个选择独立于未来可能做出的其他选择。
- `不可逆性`：一旦做出了一个选择，就不能撤销或更改，算法向前推进，依赖于之前做出的选择。
- `目标导向`：每个贪心选择都是为了直接或间接地推进达到全局最优解的目标，即使在面临多个可能的局部解时也是如此。
- `适用性限制`：并非所有问题都适用贪心算法，只有当问题满足“贪心选择性质”并且存在“最优子结构”，即子问题的最优解能组合成原问题的最优解时，贪心算法才能有效。

### 1.4 最优子结构

最优子结构是算法设计领域的一个重要概念，特别是在解决优化问题时。它指的是一个问题能够被分解成多个子问题，而且原问题的最优解可以通过其子问题的最优解来构建。换句话说，如果一个大问题的最优解包含其所有子问题的最优解，那么这个问题就具有最优子结构。常见运用场景包括：

- `动态规划`：动态规划算法广泛利用最优子结构来解决复杂问题。通过解决重叠子问题并存储子问题的解，动态规划避免了重复计算，从而有效构建出全局最优解。
- `贪心算法`：虽然贪心算法和动态规划都基于最优子结构，但贪心算法在每一步都做出局部最优决策，期望这些决策能自然地组合成全局最优解。不过，贪心算法的成功依赖于特定问题的性质，即局部最优能直接或间接导致全局最优。

### 1.5 贪心算法的局限性

- 全局优化难以保证：在一些问题中，局部最优决策未必导向全局最优解。
- 问题依赖性：仅适用于具有特定性质的问题，比如贪心选择性质和最优子结构。
- 缺乏回溯机制：一旦做出选择，就无法撤销或修正，可能导致错过全局最优解。

## 二、实现步骤

1. `识别问题的贪心选择性质`：确定一个局部选择标准，使得在每一步都能做出最佳决策。套用贪心算法问题模型。限制值，期望值。每次选出不超过限制值的，最大期望值。
2. `构建解决方案`：按照贪心选择性质，逐步构建问题的解。每次选择对限制值同等贡献量的情况下，对期望值贡献最大的值。
3. `证明可行性`：确保通过贪心策略获得的解是合法的，满足问题的基本约束。
4. `评估全局最优性`：分析并验证最终解是否为全局最优或接近最优。

## 三、应用案例

### 3.1 活动选择问题

给定一系列活动，每个活动都有一个开始时间和结束时间，选择尽可能多的活动，使得它们之间互不冲突。

```js
function activitySelection(startTimes, endTimes) {
  // 按照结束时间对活动排序
  const activities = startTimes
    .map((start, index) => [start, endTimes[index]])
    .sort((a, b) => a[1] - b[1]);

  // 初始化第一个活动
  let lastEnd = activities[0][1];
  let count = 1;

  for (let i = 1; i < activities.length; i++) {
    // 如果下一个活动的开始时间大于等于上一个活动的结束时间
    if (activities[i][0] >= lastEnd) {
      count += 1;
      lastEnd = activities[i][1];
    }
  }

  return count;
}

// 示例
const startTimes = [1, 3, 0, 5, 8, 5];
const endTimes = [2, 4, 6, 7, 9, 9];
console.log("最多可进行的活动数量:", activitySelection(startTimes, endTimes));
```

### 3.2 其他案例

（1）[分糖果](https://leetcode.cn/problems/distribute-candies/description/)
在保证公平性的前提下，最大化每个孩子的糖果数。

（2）最短服务时间
优化服务顺序，以减少总体等待时间。

（3）[无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/description/)
通过最少移除区间数，确保所有区间互不重叠。
